<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--This file was generated by pandoc: do not edit--><head>

<meta name="author" content="John J. Lee &lt;jjl@pobox.com&gt;">
<meta name="date" content="2011-03-31">
<meta name="keywords" content="Python,HTML,HTTP,browser,stateful,web,client,client-side,mechanize,cookie,form,META,HTTP-EQUIV,Refresh,ClientForm,ClientCookie,pullparser,WWW::Mechanize">
<meta name="keywords" content="cookie,HTTP,Python,web,client,client-side,HTML,META,HTTP-EQUIV,Refresh">
<style type="text/css" media="screen">@import "../styles/style.css";</style>
<!--breaks resizing text in IE6,7,8 (the lack of it also breaks baseline grid a bit in IE8 - can't win)--><!--[if !IE]>--><style type="text/css" media="screen">body{font-size:14px;}</style>
<!--<![endif]--><!--max-width--><!--[if IE 6]><script type="text/javascript" src="../styles/ie6.js"></script><![endif]--><title>mechanize &#8212; Documentation</title>
</head>
<body>
<div id="sf">
<a href="http://sourceforge.net/"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=48205&amp;type=10" width="80" height="15" alt="SourceForge.net. Fast, secure and Free Open Source software downloads"></a>
</div>
<div id="content">

<ul id="nav">
<li>
<a href="./">
Home
</a>
</li>
<li>
<a href="download.html">
Download
</a>
</li>
<li>
<span class="thispage">
Support
</span>
</li>
<li>
<a href="development.html">
Development
</a>
</li>
</ul>
<div id="main">

<h1 class="title">mechanize &#8212; Documentation</h1>

<ul id="subnav">
<li>
<a href="support.html">
Support
</a>
<ul>
<li>
<a href="documentation.html">
Documentation
</a>
<ul>
<li>
<a href="faq.html">
FAQ
</a>
</li>
<li>
<span class="thispage">
Handlers etc.
</span>
</li>
<li>
<a href="forms.html">
Forms
</a>
</li>
<li>
<a href="hints.html">
Hints
</a>
</li>
</ul>
</li>
<li>
<a href="ChangeLog.txt">
Changelog
</a>
</li>
</ul>
</li>
</ul>
<div id="TOC"><ul>
<li><a href="#examples">Examples</a></li>
<li><a href="#important-note">Important note</a></li>
<li><a href="#cooperating-with-browsers">Cooperating with Browsers</a></li>
<li><a href="#saving-cookies-in-a-file">Saving cookies in a file</a></li>
<li><a href="#supplying-a-cookiejar">Supplying a CookieJar</a></li>
<li><a href="#additional-handlers">Additional Handlers</a></li>
<li><a href="#seekable-responses">Seekable responses</a></li>
<li><a href="#request-object-lifetime">Request object lifetime</a></li>
<li><a href="#adding-headers">Adding headers</a></li>
<li><a href="#automatically-added-headers">Automatically-added headers</a></li>
<li><a href="#initiating-unverifiable-transactions">Initiating unverifiable transactions</a></li>
<li><a href="#rfc-2965-support">RFC 2965 support</a></li>
<li><a href="#parsing-http-dates">Parsing HTTP dates</a></li>
<li><a href="#dealing-with-bad-html">Dealing with bad HTML</a></li>
<li><a href="#note-about-cookie-standards">Note about cookie standards</a></li>
</ul></div>

<p><span class="docwarning">This documentation is in need of reorganisation!</span></p>
<p>This page is the old ClientCookie documentation. It deals with operation on the level of <code>urllib2 Handler</code> objects, and also with adding headers, debugging, and cookie handling. See the <a href="./">front page</a> for more typical use.</p>
<div id="examples">
<h2>Examples</h2>
<pre class="sourceCode python"><span class="ch">import</span> mechanize<br>response = mechanize.urlopen(<span class="st">"http://example.com/"</span>)<br></pre>
<p>This function behaves identically to <code>urllib2.urlopen()</code>, except that it deals with cookies automatically.</p>
<p>Here is a more complicated example, involving <code>Request</code> objects (useful if you want to pass <code>Request</code>s around, add headers to them, etc.):</p>
<pre class="sourceCode python"><span class="ch">import</span> mechanize<br>request = mechanize.Request(<span class="st">"http://example.com/"</span>)<br><span class="co"># note we're using the urlopen from mechanize, not urllib2</span><br>response = mechanize.urlopen(request)<br><span class="co"># let's say this next request requires a cookie that was set</span><br><span class="co"># in response</span><br>request2 = mechanize.Request(<span class="st">"http://example.com/spam.html"</span>)<br>response2 = mechanize.urlopen(request2)<br><br><span class="kw">print</span> response2.geturl()<br><span class="kw">print</span> response2.info()  <span class="co"># headers</span><br><span class="kw">print</span> response2.read()  <span class="co"># body (readline and readlines work too)</span><br></pre>
<p>In these examples, the workings are hidden inside the <code>mechanize.urlopen()</code> function, which is an extension of <code>urllib2.urlopen()</code>. Redirects, proxies and cookies are handled automatically by this function (note that you may need a bit of configuration to get your proxies correctly set up: see <code>urllib2</code> documentation).</p>
<p>There is also a <code>urlretrieve()</code> function, which works like <code>urllib.urlretrieve()</code>.</p>
<p>An example at a slightly lower level shows how the module processes cookies more clearly:</p>
<pre class="sourceCode python"><span class="co"># Don't copy this blindly!  You probably want to follow the examples</span><br><span class="co"># above, not this one.</span><br><span class="ch">import</span> mechanize<br><br><span class="co"># Build an opener that *doesn't* automatically call .add_cookie_header()</span><br><span class="co"># and .extract_cookies(), so we can do it manually without interference.</span><br><span class="kw">class</span> NullCookieProcessor(mechanize.HTTPCookieProcessor):<br><span class="kw">def</span> http_request(<span class="ot">self</span>, request): <span class="kw">return</span> request<br><span class="kw">def</span> http_response(<span class="ot">self</span>, request, response): <span class="kw">return</span> response<br>opener = mechanize.build_opener(NullCookieProcessor)<br><br>request = mechanize.Request(<span class="st">"http://example.com/"</span>)<br>response = mechanize.urlopen(request)<br>cj = mechanize.CookieJar()<br>cj.extract_cookies(response, request)<br><span class="co"># let's say this next request requires a cookie that was set in response</span><br>request2 = mechanize.Request(<span class="st">"http://example.com/spam.html"</span>)<br>cj.add_cookie_header(request2)<br>response2 = mechanize.urlopen(request2)<br></pre>
<p>The <code>CookieJar</code> class does all the work. There are essentially two operations: <code>.extract_cookies()</code> extracts HTTP cookies from <code>Set-Cookie</code> (the original <a href="http://curl.haxx.se/rfc/cookie_spec.html">Netscape cookie standard</a>) and <code>Set-Cookie2</code> (<a href="http://www.ietf.org/rfc/rfc2965.txt">RFC 2965</a>) headers from a response if and only if they should be set given the request, and <code>.add_cookie_header()</code> adds <code>Cookie</code> headers if and only if they are appropriate for a particular HTTP request. Incoming cookies are checked for acceptability based on the host name, etc. Cookies are only set on outgoing requests if they match the request&#8217;s host name, path, etc.</p>
<p><strong>Note that if you&#8217;re using <code>mechanize.urlopen()</code> (or if you&#8217;re using <code>mechanize.HTTPCookieProcessor</code> by some other means), you don&#8217;t need to call <code>.extract_cookies()</code> or <code>.add_cookie_header()</code> yourself</strong>. If, on the other hand, you want to use mechanize to provide cookie handling for an HTTP client other than mechanize itself, you will need to use this pair of methods. You can make your own <code>request</code> and <code>response</code> objects, which must support the interfaces described in the docstrings of <code>.extract_cookies()</code> and <code>.add_cookie_header()</code>.</p>
<p>There are also some <code>CookieJar</code> subclasses which can store cookies in files and databases. <code>FileCookieJar</code> is the abstract class for <code>CookieJar</code>s that can store cookies in disk files. <code>LWPCookieJar</code> saves cookies in a format compatible with the libwww-perl library. This class is convenient if you want to store cookies in a human-readable file:</p>
<pre class="sourceCode python"><span class="ch">import</span> mechanize<br>cj = mechanize.LWPCookieJar()<br>cj.revert(<span class="st">"cookie3.txt"</span>)<br>opener = mechanize.build_opener(mechanize.HTTPCookieProcessor(cj))<br>r = opener.<span class="dt">open</span>(<span class="st">"http://foobar.com/"</span>)<br>cj.save(<span class="st">"cookie3.txt"</span>)<br></pre>
<p>The <code>.revert()</code> method discards all existing cookies held by the <code>CookieJar</code> (it won&#8217;t lose any existing cookies if the load fails). The <code>.load()</code> method, on the other hand, adds the loaded cookies to existing cookies held in the <code>CookieJar</code> (old cookies are kept unless overwritten by newly loaded ones).</p>
<p><code>MozillaCookieJar</code> can load and save to the Mozilla/Netscape/lynx-compatible <code>'cookies.txt'</code> format. This format loses some information (unusual and nonstandard cookie attributes such as comment, and also information specific to RFC 2965 cookies). The subclass <code>MSIECookieJar</code> can load (but not save) from Microsoft Internet Explorer&#8217;s cookie files on Windows.</p>
</div>
<div id="important-note">
<h2>Important note</h2>
<p>Only use names you can import directly from the <code>mechanize</code> package, and that don&#8217;t start with a single underscore. Everything else is subject to change or disappearance without notice.</p>
</div>
<div id="cooperating-with-browsers">
<h2>Cooperating with Browsers</h2>
<p><strong>Firefox since version 3 persists cookies in an sqlite database, which is not supported by MozillaCookieJar.</strong></p>
<p>The subclass <code>MozillaCookieJar</code> differs from <code>CookieJar</code> only in storing cookies using a different, Firefox 2/Mozilla/Netscape-compatible, file format known as &#8220;cookies.txt&#8221;. The lynx browser also uses this format. This file format can&#8217;t store RFC 2965 cookies, so they are downgraded to Netscape cookies on saving. <code>LWPCookieJar</code> itself uses a libwww-perl specific format (`Set-Cookie3&#8217;) &#8212; see the example above. Python and your browser should be able to share a cookies file (note that the file location here will differ on non-unix OSes):</p>
<p><strong>WARNING:</strong> you may want to back up your browser&#8217;s cookies file if you use <code>MozillaCookieJar</code> to save cookies. I <em>think</em> it works, but there have been bugs in the past!</p>
<pre class="sourceCode python"><span class="ch">import</span> os, mechanize<br>cookies = mechanize.MozillaCookieJar()<br>cookies.load(os.path.join(os.environ[<span class="st">"HOME"</span>], <span class="st">"/.netscape/cookies.txt"</span>))<br><span class="co"># see also the save and revert methods</span><br></pre>
<p>Note that cookies saved while Mozilla is running will get clobbered by Mozilla &#8212; see <code>MozillaCookieJar.__doc__</code>.</p>
<p><code>MSIECookieJar</code> does the same for Microsoft Internet Explorer (MSIE) 5.x and 6.x on Windows, but does not allow saving cookies in this format. In future, the Windows API calls might be used to load and save (though the index has to be read directly, since there is no API for that, AFAIK; there&#8217;s also an unfinished <code>MSIEDBCookieJar</code>, which uses (reads and writes) the Windows MSIE cookie database directly, rather than storing copies of cookies as <code>MSIECookieJar</code> does).</p>
<pre class="sourceCode python"><span class="ch">import</span> mechanize<br>cj = mechanize.MSIECookieJar(delayload=<span class="ot">True</span>)<br>cj.load_from_registry()  <span class="co"># finds cookie index file from registry</span><br></pre>
<p>A true <code>delayload</code> argument speeds things up.</p>
<p>On Windows 9x (win 95, win 98, win ME), you need to supply a username to the <code>.load_from_registry()</code> method:</p>
<pre class="sourceCode python">cj.load_from_registry(username=<span class="st">"jbloggs"</span>)<br></pre>
<p>Konqueror/Safari and Opera use different file formats, which aren&#8217;t yet supported.</p>
</div>
<div id="saving-cookies-in-a-file">
<h2>Saving cookies in a file</h2>
<p>If you have no need to co-operate with a browser, the most convenient way to save cookies on disk between sessions in human-readable form is to use <code>LWPCookieJar</code>. This class uses a libwww-perl specific format (`Set-Cookie3&#8217;). Unlike <code>MozilliaCookieJar</code>, this file format doesn&#8217;t lose information.</p>
</div>
<div id="supplying-a-cookiejar">
<h2>Supplying a CookieJar</h2>
<p>You might want to do this to <a href="#cooperating-with-browsers">use your browser&#8217;s cookies</a>, to customize <code>CookieJar</code>&#8217;s behaviour by passing constructor arguments, or to be able to get at the cookies it will hold (for example, for saving cookies between sessions and for debugging).</p>
<p>If you&#8217;re using the higher-level <code>urllib2</code>-like interface (<code>urlopen()</code>, etc), you&#8217;ll have to let it know what <code>CookieJar</code> it should use:</p>
<pre class="sourceCode python"><span class="ch">import</span> mechanize<br>cookies = mechanize.CookieJar()<br><span class="co"># build_opener() adds standard handlers (such as HTTPHandler and</span><br><span class="co"># HTTPCookieProcessor) by default.  The cookie processor we supply</span><br><span class="co"># will replace the default one.</span><br>opener = mechanize.build_opener(mechanize.HTTPCookieProcessor(cookies))<br><br>r = opener.<span class="dt">open</span>(<span class="st">"http://example.com/"</span>)  <span class="co"># GET</span><br>r = opener.<span class="dt">open</span>(<span class="st">"http://example.com/"</span>, data)  <span class="co"># POST</span><br></pre>
<p>The <code>urlopen()</code> function uses a global <code>OpenerDirector</code> instance to do its work, so if you want to use <code>urlopen()</code> with your own <code>CookieJar</code>, install the <code>OpenerDirector</code> you built with <code>build_opener()</code> using the <code>mechanize.install_opener()</code> function, then proceed as usual:</p>
<pre class="sourceCode python">mechanize.install_opener(opener)<br>r = mechanize.urlopen(<span class="st">"http://example.com/"</span>)<br></pre>
<p>Of course, everyone using <code>urlopen</code> is using the same global <code>CookieJar</code> instance!</p>
<a name="policy"></a><p>You can set a policy object (must satisfy the interface defined by <code>mechanize.CookiePolicy</code>), which determines which cookies are allowed to be set and returned. Use the <code>policy</code> argument to the <code>CookieJar</code> constructor, or use the <code>.set\_policy()</code> method. The default implementation has some useful switches:</p>
<pre class="sourceCode python"><span class="ch">from</span> mechanize <span class="ch">import</span> CookieJar, DefaultCookiePolicy <span class="ch">as</span> Policy<br>cookies = CookieJar()<br><span class="co"># turn on RFC 2965 cookies, be more strict about domains when setting and</span><br><span class="co"># returning Netscape cookies, and block some domains from setting cookies</span><br><span class="co"># or having them returned (read the DefaultCookiePolicy docstring for the</span><br><span class="co"># domain matching rules here)</span><br>policy = Policy(rfc2965=<span class="ot">True</span>, strict_ns_domain=Policy.DomainStrict,<br>                blocked_domains=[<span class="st">"ads.net"</span>, <span class="st">".ads.net"</span>])<br>cookies.set_policy(policy)<br></pre>
</div>
<div id="additional-handlers">
<h2>Additional Handlers</h2>
<p>The following handlers are provided in addition to those provided by <code>urllib2</code>:</p>
<dl>
<dt><code>HTTPRobotRulesProcessor</code></dt>
<dd><p>WWW Robots (also called wanderers or spiders) are programs that traverse many pages in the World Wide Web by recursively retrieving linked pages. This kind of program can place significant loads on web servers, so there is a <a href="http://www.robotstxt.org/wc/norobots.html">standard</a> for a <code>robots.txt</code> file by which web site operators can request robots to keep out of their site, or out of particular areas of it. This handler uses the standard Python library&#8217;s <code>robotparser</code> module. It raises <code>mechanize.RobotExclusionError</code> (subclass of <code>mechanize.HTTPError</code>) if an attempt is made to open a URL prohibited by <code>robots.txt</code>.</p></dd>
<dt><code>HTTPEquivProcessor</code></dt>
<dd><p>The <code>&lt;META HTTP-EQUIV&gt;</code> tag is a way of including data in HTML to be treated as if it were part of the HTTP headers. mechanize can automatically read these tags and add the <code>HTTP-EQUIV</code> headers to the response object&#8217;s real HTTP headers. The HTML is left unchanged.</p></dd>
<dt><code>HTTPRefreshProcessor</code></dt>
<dd><p>The <code>Refresh</code> HTTP header is a non-standard header which is widely used. It requests that the user-agent follow a URL after a specified time delay. mechanize can treat these headers (which may have been set in <code>&lt;META HTTP-EQUIV&gt;</code> tags) as if they were 302 redirections. Exactly when and how <code>Refresh</code> headers are handled is configurable using the constructor arguments.</p></dd>
<dt><code>HTTPRefererProcessor</code></dt>
<dd><p>The <code>Referer</code> HTTP header lets the server know which URL you&#8217;ve just visited. Some servers use this header as state information, and don&#8217;t like it if this is not present. It&#8217;s a chore to add this header by hand every time you make a request. This adds it automatically. <strong>NOTE</strong>: this only makes sense if you use each handler for a single chain of HTTP requests (so, for example, if you use a single HTTPRefererProcessor to fetch a series of URLs extracted from a single page, <strong>this will break</strong>). <a href="../mechanize/">mechanize.Browser</a> does this properly.</p></dd>
</dl>
<p>Example:</p>
<pre class="sourceCode python"><span class="ch">import</span> mechanize<br>cookies = mechanize.CookieJar()<br><br>opener = mechanize.build_opener(mechanize.HTTPRefererProcessor,<br>                                mechanize.HTTPEquivProcessor,<br>                                mechanize.HTTPRefreshProcessor,<br>                                )<br>opener.<span class="dt">open</span>(<span class="st">"http://www.rhubarb.com/"</span>)<br></pre>
</div>
<div id="seekable-responses">
<h2>Seekable responses</h2>
<p>Response objects returned from (or raised as exceptions by) <code>mechanize.SeekableResponseOpener</code>, <code>mechanize.UserAgent</code> (if <code>.set_seekable_responses(True)</code> has been called) and <code>mechanize.Browser()</code> have <code>.seek()</code>, <code>.get_data()</code> and <code>.set_data()</code> methods:</p>
<pre class="sourceCode python"><span class="ch">import</span> mechanize<br>opener = mechanize.OpenerFactory(mechanize.SeekableResponseOpener).build_opener()<br>response = opener.<span class="dt">open</span>(<span class="st">"http://example.com/"</span>)<br><span class="co"># same return value as .read(), but without affecting seek position</span><br>total_nr_bytes = <span class="dt">len</span>(response.get_data())<br>assert <span class="dt">len</span>(response.read()) == total_nr_bytes<br>assert <span class="dt">len</span>(response.read()) == <span class="dv">0</span>  <span class="co"># we've already read the data</span><br>response.seek(<span class="dv">0</span>)<br>assert <span class="dt">len</span>(response.read()) == total_nr_bytes<br>response.set_data(<span class="st">"blah</span><span class="ch">\n</span><span class="st">"</span>)<br>assert response.get_data() == <span class="st">"blah</span><span class="ch">\n</span><span class="st">"</span><br>...<br></pre>
<p>This caching behaviour can be avoided by using <code>mechanize.OpenerDirector</code>. It can also be avoided with <code>mechanize.UserAgent</code>. Note that <code>HTTPEquivProcessor</code> and <code>HTTPResponseDebugProcessor</code> require seekable responses and so are not compatible with <code>mechanize.OpenerDirector</code> and <code>mechanize.UserAgent</code>.</p>
<pre class="sourceCode python"><span class="ch">import</span> mechanize<br>ua = mechanize.UserAgent()<br>ua.set_seekable_responses(<span class="ot">False</span>)<br>ua.set_handle_equiv(<span class="ot">False</span>)<br>ua.set_debug_responses(<span class="ot">False</span>)<br></pre>
<p>Note that if you turn on features that use seekable responses (currently: HTTP-EQUIV handling and response body debug printing), returned responses <em>may</em> be seekable as a side-effect of these features. However, this is not guaranteed (currently, in these cases, returned response objects are seekable, but raised respose objects &#8212; <code>mechanize.HTTPError</code> instances &#8212; are not seekable). This applies regardless of whether you use <code>mechanize.UserAgent</code> or <code>mechanize.OpenerDirector</code>. If you explicitly request seekable responses by calling <code>.set_seekable_responses(True)</code> on a <code>mechanize.UserAgent</code> instance, or by using <code>mechanize.Browser</code> or <code>mechanize.SeekableResponseOpener</code>, which always return seekable responses, then both returned and raised responses are guaranteed to be seekable.</p>
<p>Handlers should call <code>response = mechanize.seek_wrapped_response(response)</code> if they require the <code>.seek()</code>, <code>.get_data()</code> or <code>.set_data()</code> methods.</p>
</div>
<div id="request-object-lifetime">
<h2>Request object lifetime</h2>
<p>Note that handlers may create new <code>Request</code> instances (for example when performing redirects) rather than adding headers to existing <code>Request</code> objects.</p>
</div>
<div id="adding-headers">
<h2>Adding headers</h2>
<p>Adding headers is done like so:</p>
<pre class="sourceCode python"><span class="ch">import</span> mechanize<br>req = mechanize.Request(<span class="st">"http://foobar.com/"</span>)<br>req.add_header(<span class="st">"Referer"</span>, <span class="st">"http://wwwsearch.sourceforge.net/mechanize/"</span>)<br>r = mechanize.urlopen(req)<br></pre>
<p>You can also use the <code>headers</code> argument to the <code>mechanize.Request</code> constructor.</p>
<p>mechanize adds some headers to <code>Request</code> objects automatically &#8212; see the next section for details.</p>
</div>
<div id="automatically-added-headers">
<h2>Automatically-added headers</h2>
<p><code>OpenerDirector</code> automatically adds a <code>User-Agent</code> header to every <code>Request</code>.</p>
<p>To change this and/or add similar headers, use your own <code>OpenerDirector</code>:</p>
<pre class="sourceCode python"><span class="ch">import</span> mechanize<br>cookies = mechanize.CookieJar()<br>opener = mechanize.build_opener(mechanize.HTTPCookieProcessor(cookies))<br>opener.addheaders = [(<span class="st">"User-agent"</span>, <span class="st">"Mozilla/5.0 (compatible; MyProgram/0.1)"</span>),<br>                     (<span class="st">"From"</span>, <span class="st">"responsible.person@example.com"</span>)]<br></pre>
<p>Again, to use <code>urlopen()</code>, install your <code>OpenerDirector</code> globally:</p>
<pre class="sourceCode python">mechanize.install_opener(opener)<br>r = mechanize.urlopen(<span class="st">"http://example.com/"</span>)<br></pre>
<p>Also, a few standard headers (<code>Content-Length</code>, <code>Content-Type</code> and <code>Host</code>) are added when the <code>Request</code> is passed to <code>urlopen()</code> (or <code>OpenerDirector.open()</code>). You shouldn&#8217;t need to change these headers, but since this is done by <code>AbstractHTTPHandler</code>, you can change the way it works by passing a subclass of that handler to <code>build_opener()</code> (or, as always, by constructing an opener yourself and calling <code>.add_handler()</code>).</p>
</div>
<div id="initiating-unverifiable-transactions">
<h2>Initiating unverifiable transactions</h2>
<p>This section is only of interest for correct handling of third-party HTTP cookies. See <a href="#note-about-cookie-standards">below</a> for an explanation of &#8216;third-party&#8217;.</p>
<p>First, some terminology.</p>
<p>An <em>unverifiable request</em> (defined fully by (<a href="http://www.ietf.org/rfc/rfc2965.txt">RFC 2965</a>) is one whose URL the user did not have the option to approve. For example, a transaction is unverifiable if the request is for an image in an HTML document, and the user had no option to approve the fetching of the image from a particular URL.</p>
<p>The <em>request-host of the origin transaction</em> (defined fully by RFC 2965) is the host name or IP address of the original request that was initiated by the user. For example, if the request is for an image in an HTML document, this is the request-host of the request for the page containing the image.</p>
<p><strong>mechanize knows that redirected transactions are unverifiable, and will handle that on its own (ie. you don&#8217;t need to think about the origin request-host or verifiability yourself).</strong></p>
<p>If you want to initiate an unverifiable transaction yourself (which you should if, for example, you&#8217;re downloading the images from a page, and &#8216;the user&#8217; hasn&#8217;t explicitly OKed those URLs):</p>
<pre class="sourceCode python">request = Request(origin_req_host=<span class="st">"www.example.com"</span>, unverifiable=<span class="ot">True</span>)<br></pre>
</div>
<div id="rfc-2965-support">
<h2>RFC 2965 support</h2>
<p>Support for the RFC 2965 protocol is switched off by default, because few browsers implement it, so the RFC 2965 protocol is essentially never seen on the internet. To switch it on, see <a href="#policy">here</a>.</p>
</div>
<div id="parsing-http-dates">
<h2>Parsing HTTP dates</h2>
<p>A function named <code>str2time</code> is provided by the package, which may be useful for parsing dates in HTTP headers. <code>str2time</code> is intended to be liberal, since HTTP date/time formats are poorly standardised in practice. There is no need to use this function in normal operations: <code>CookieJar</code> instances keep track of cookie lifetimes automatically. This function will stay around in some form, though the supported date/time formats may change.</p>
</div>
<div id="dealing-with-bad-html">
<h2>Dealing with bad HTML</h2>
<p>XXX Intro</p>
<p>XXX Test me</p>
</div>
<div id="note-about-cookie-standards">
<h2>Note about cookie standards</h2>
<p>There are several standards relevant to HTTP cookies.</p>
<p>The Netscape protocol is the only standard supported by most web browsers (including Internet Explorer and Firefox). This is a <em>de facto</em> standard defined by the behaviour of popular browsers, and neither the <a href="http://curl.haxx.se/rfc/cookie_spec.html">cookie_spec.html</a> document that was published by Netscape, nor the RFCs that were published later, describe the Netscape protocol accurately or completely. Netscape protocol cookies are also known as V0 cookies, to distinguish them from RFC 2109 or RFC 2965 cookies, which have a version cookie-attribute with a value of 1.</p>
<p><a href="http://www.ietf.org/rfc/rfc2109.txt">RFC 2109</a> was introduced to fix some problems identified with the Netscape protocol, while still keeping the same HTTP headers (<code>Cookie</code> and <code>Set-Cookie</code>). The most prominent of these problems is the &#8216;third-party&#8217; cookie issue, which was an accidental feature of the Netscape protocol. Some features defined by RFC2109 (such as the port and max-age cookie attributes) are now part of the de facto Netscape protocol, but the RFC was never implemented fully by browsers, because of differences in behaviour between the Netscape and Internet Explorer browsers of the time.</p>
<p><a href="http://www.ietf.org/rfc/rfc2965.txt">RFC 2965</a> attempted to fix the compatibility problem by introducing two new headers, <code>Set-Cookie2</code> and <code>Cookie2</code>. Unlike the <code>Cookie</code> header, <code>Cookie2</code> does <em>not</em> carry cookies to the server &#8212; rather, it simply advertises to the server that RFC 2965 is understood. <code>Set-Cookie2</code> <em>does</em> carry cookies, from server to client: the new header means that both IE and Netscape ignore these cookies. This preserves backwards compatibility, but popular browsers did not implement the RFC, so it was never widely adopted. One confusing point to note about RFC 2965 is that it uses the same value (1) of the Version attribute in HTTP headers as does RFC 2109. See also <a href="http://www.ietf.org/rfc/rfc2964.txt">RFC 2964</a>, which discusses use of the protocol.</p>
<p>Because Netscape cookies are so poorly specified, the general philosophy of the module&#8217;s Netscape protocol implementation is to start with RFC 2965 and open holes where required for Netscape protocol-compatibility. RFC 2965 cookies are <em>always</em> treated as RFC 2965 requires, of course.</p>
<p>There is more information about the history of HTTP cookies in <a href="http://arxiv.org/abs/cs.SE/0105018">this paper by David Kristol</a>.</p>
<p>Recently (2011), <a href="http://tools.ietf.org/html/draft-ietf-httpstate-cookie">an IETF effort has started</a> to specify the syntax and semantics of the <code>Cookie</code> and <code>Set-Cookie</code> headers as they are actually used on the internet.</p>
</div>

<p>I prefer questions and comments to be sent to
the <a href="http://lists.sourceforge.net/lists/listinfo/wwwsearch-general">mailing
list</a> rather than direct to me.</p>

<p><a href="mailto:jjl@pobox.com">John J. Lee</a>, March 2011.

</p>
<hr>
</div>
</div>
</body>
</html>

