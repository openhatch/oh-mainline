<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--This file was generated by pandoc: do not edit--><head>

<meta name="author" content="John J. Lee &lt;jjl@pobox.com&gt;">
<meta name="date" content="2010-04-22">
<meta name="keywords" content="Python,HTML,HTTP,browser,stateful,web,client,client-side,mechanize,cookie,form,META,HTTP-EQUIV,Refresh,ClientForm,ClientCookie,pullparser,WWW::Mechanize">
<meta name="keywords" content="cookie,HTTP,Python,web,client,client-side,HTML,META,HTTP-EQUIV,Refresh">
<style type="text/css" media="screen">@import "../styles/style.css";</style>
<!--breaks resizing text in IE6,7,8 (the lack of it also breaks baseline grid a bit in IE8 - can't win)--><!--[if !IE]>--><style type="text/css" media="screen">body{font-size:14px;}</style>
<!--<![endif]--><!--max-width--><!--[if IE 6]><script type="text/javascript" src="../styles/ie6.js"></script><![endif]--><title>mechanize &#8212; Forms</title>
</head>
<body>
<div id="sf">
<a href="http://sourceforge.net/"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=48205&amp;type=10" width="80" height="15" alt="SourceForge.net. Fast, secure and Free Open Source software downloads"></a>
</div>
<div id="content">

<ul id="nav">
<li>
<a href="./">
Home
</a>
</li>
<li>
<a href="download.html">
Download
</a>
</li>
<li>
<span class="thispage">
Support
</span>
</li>
<li>
<a href="development.html">
Development
</a>
</li>
</ul>
<div id="main">

<h1 class="title">mechanize &#8212; Forms</h1>

<ul id="subnav">
<li>
<a href="support.html">
Support
</a>
<ul>
<li>
<a href="documentation.html">
Documentation
</a>
<ul>
<li>
<a href="faq.html">
FAQ
</a>
</li>
<li>
<a href="doc.html">
Handlers etc.
</a>
</li>
<li>
<span class="thispage">
Forms
</span>
</li>
<li>
<a href="hints.html">
Hints
</a>
</li>
</ul>
</li>
<li>
<a href="ChangeLog.txt">
Changelog
</a>
</li>
</ul>
</li>
</ul>
<div id="TOC"><ul>
<li><a href="#parsers">Parsers</a></li>
<li><a href="#backwards-compatibility-mode">Backwards-compatibility mode</a></li>
</ul></div>

<p><span class="docwarning">This documentation is in need of reorganisation!</span></p>
<p>This page is the old ClientForm documentation. ClientForm is now part of mechanize, but the documentation hasn&#8217;t been fully updated to reflect that: what&#8217;s here is correct, but not well-integrated with the rest of the documentation. This page deals with HTML form handling: parsing HTML forms, filling them in and returning the completed forms to the server. See the <a href="./">front page</a> for how to obtain form objects from a <code>mechanize.Browser</code>.</p>
<p>Simple working example (<code>examples/forms/simple.py</code> in the source distribution):</p>
<pre class="sourceCode python"><span class="ch">import</span> sys<br><br><span class="ch">from</span> mechanize <span class="ch">import</span> ParseResponse, urlopen, urljoin<br><br><span class="kw">if</span> <span class="dt">len</span>(sys.argv) == <span class="dv">1</span>:<br>    uri = <span class="st">"http://wwwsearch.sourceforge.net/"</span><br><span class="kw">else</span>:<br>    uri = sys.argv[<span class="dv">1</span>]<br><br>response = urlopen(urljoin(uri, <span class="st">"mechanize/example.html"</span>))<br>forms = ParseResponse(response, backwards_compat=<span class="ot">False</span>)<br>form = forms[<span class="dv">0</span>]<br><span class="kw">print</span> form<br>form[<span class="st">"comments"</span>] = <span class="st">"Thanks, Gisle"</span><br><br><span class="co"># form.click() returns a mechanize.Request object</span><br><span class="co"># (see HTMLForm.click.__doc__ if you want to use only the forms support, and</span><br><span class="co"># not the rest of mechanize)</span><br><span class="kw">print</span> urlopen(form.click()).read()<br></pre>
<p>A more complicated working example (from <code>examples/forms/example.py</code> in the source distribution):</p>
<pre class="sourceCode python"><span class="ch">import</span> sys<br><br><span class="ch">import</span> mechanize<br><br><span class="kw">if</span> <span class="dt">len</span>(sys.argv) == <span class="dv">1</span>:<br>    uri = <span class="st">"http://wwwsearch.sourceforge.net/"</span><br><span class="kw">else</span>:<br>    uri = sys.argv[<span class="dv">1</span>]<br><br>request = mechanize.Request(mechanize.urljoin(uri, <span class="st">"mechanize/example.html"</span>))<br>response = mechanize.urlopen(request)<br>forms = mechanize.ParseResponse(response, backwards_compat=<span class="ot">False</span>)<br>response.close()<br><span class="co">## f = open("example.html")</span><br><span class="co">## forms = mechanize.ParseFile(f, "http://example.com/example.html",</span><br><span class="co">##                              backwards_compat=False)</span><br><span class="co">## f.close()</span><br>form = forms[<span class="dv">0</span>]<br><span class="kw">print</span> form  <span class="co"># very useful!</span><br><br><span class="co"># A 'control' is a graphical HTML form widget: a text entry box, a</span><br><span class="co"># dropdown 'select' list, a checkbox, etc.</span><br><br><span class="co"># Indexing allows setting and retrieval of control values</span><br>original_text = form[<span class="st">"comments"</span>]  <span class="co"># a string, NOT a Control instance</span><br>form[<span class="st">"comments"</span>] = <span class="st">"Blah."</span><br><br><span class="co"># Controls that represent lists (checkbox, select and radio lists) are</span><br><span class="co"># ListControl instances.  Their values are sequences of list item names.</span><br><span class="co"># They come in two flavours: single- and multiple-selection:</span><br>form[<span class="st">"favorite_cheese"</span>] = [<span class="st">"brie"</span>]  <span class="co"># single</span><br>form[<span class="st">"cheeses"</span>] = [<span class="st">"parmesan"</span>, <span class="st">"leicester"</span>, <span class="st">"cheddar"</span>]  <span class="co"># multi</span><br><span class="co">#  equivalent, but more flexible:</span><br>form.set_value([<span class="st">"parmesan"</span>, <span class="st">"leicester"</span>, <span class="st">"cheddar"</span>], name=<span class="st">"cheeses"</span>)<br><br><span class="co"># Add files to FILE controls with .add_file().  Only call this multiple</span><br><span class="co"># times if the server is expecting multiple files.</span><br><span class="co">#  add a file, default value for MIME type, no filename sent to server</span><br>form.add_file(<span class="dt">open</span>(<span class="st">"data.dat"</span>))<br><span class="co">#  add a second file, explicitly giving MIME type, and telling the server</span><br><span class="co">#   what the filename is</span><br>form.add_file(<span class="dt">open</span>(<span class="st">"data.txt"</span>), <span class="st">"text/plain"</span>, <span class="st">"data.txt"</span>)<br><br><span class="co"># All Controls may be disabled (equivalent of greyed-out in browser)...</span><br>control = form.find_control(<span class="st">"comments"</span>)<br><span class="kw">print</span> control.disabled<br><span class="co">#  ...or readonly</span><br><span class="kw">print</span> control.readonly<br><span class="co">#  readonly and disabled attributes can be assigned to</span><br>control.disabled = <span class="ot">False</span><br><span class="co">#  convenience method, used here to make all controls writable (unless</span><br><span class="co">#   they're disabled):</span><br>form.set_all_readonly(<span class="ot">False</span>)<br><br><span class="co"># A couple of notes about list controls and HTML:</span><br><br><span class="co"># 1. List controls correspond to either a single SELECT element, or</span><br><span class="co"># multiple INPUT elements.  Items correspond to either OPTION or INPUT</span><br><span class="co"># elements.  For example, this is a SELECT control, named "control1":</span><br><br><span class="co">#    &lt;select name="control1"&gt;</span><br><span class="co">#     &lt;option&gt;foo&lt;/option&gt;</span><br><span class="co">#     &lt;option value="1"&gt;bar&lt;/option&gt;</span><br><span class="co">#    &lt;/select&gt;</span><br><br><span class="co"># and this is a CHECKBOX control, named "control2":</span><br><br><span class="co">#    &lt;input type="checkbox" name="control2" value="foo" id="cbe1"&gt;</span><br><span class="co">#    &lt;input type="checkbox" name="control2" value="bar" id="cbe2"&gt;</span><br><br><span class="co"># You know the latter is a single control because all the name attributes</span><br><span class="co"># are the same.</span><br><br><span class="co"># 2. Item names are the strings that go to make up the value that should</span><br><span class="co"># be returned to the server.  These strings come from various different</span><br><span class="co"># pieces of text in the HTML.  The HTML standard and the mechanize</span><br><span class="co"># docstrings explain in detail, but playing around with an HTML file,</span><br><span class="co"># ParseFile() and 'print form' is very useful to understand this!</span><br><br><span class="co"># You can get the Control instances from inside the form...</span><br>control = form.find_control(<span class="st">"cheeses"</span>, <span class="dt">type</span>=<span class="st">"select"</span>)<br><span class="kw">print</span> control.name, control.value, control.<span class="dt">type</span><br>control.value = [<span class="st">"mascarpone"</span>, <span class="st">"curd"</span>]<br><span class="co"># ...and the Item instances from inside the Control</span><br>item = control.get(<span class="st">"curd"</span>)<br><span class="kw">print</span> item.name, item.selected, item.<span class="dt">id</span>, item.attrs<br>item.selected = <span class="ot">False</span><br><br><span class="co"># Controls may be referred to by label:</span><br><span class="co">#  find control with label that has a *substring* "Cheeses"</span><br><span class="co">#  (e.g., a label "Please select a cheese" would match).</span><br>control = form.find_control(label=<span class="st">"select a cheese"</span>)<br><br><span class="co"># You can explicitly say that you're referring to a ListControl:</span><br><span class="co">#  set value of "cheeses" ListControl</span><br>form.set_value([<span class="st">"gouda"</span>], name=<span class="st">"cheeses"</span>, kind=<span class="st">"list"</span>)<br><span class="co">#  equivalent:</span><br>form.find_control(name=<span class="st">"cheeses"</span>, kind=<span class="st">"list"</span>).value = [<span class="st">"gouda"</span>]<br><span class="co">#  the first example is also almost equivalent to the following (but</span><br><span class="co">#  insists that the control be a ListControl -- so it will skip any</span><br><span class="co">#  non-list controls that come before the control we want)</span><br>form[<span class="st">"cheeses"</span>] = [<span class="st">"gouda"</span>]<br><span class="co"># The kind argument can also take values "multilist", "singlelist", "text",</span><br><span class="co"># "clickable" and "file":</span><br><span class="co">#  find first control that will accept text, and scribble in it</span><br>form.set_value(<span class="st">"rhubarb rhubarb"</span>, kind=<span class="st">"text"</span>, nr=<span class="dv">0</span>)<br><span class="co">#  find, and set the value of, the first single-selection list control</span><br>form.set_value([<span class="st">"spam"</span>], kind=<span class="st">"singlelist"</span>, nr=<span class="dv">0</span>)<br><br><span class="co"># You can find controls with a general predicate function:</span><br><span class="kw">def</span> control_has_caerphilly(control):<br><span class="kw">for</span> item in control.items:<br><span class="kw">if</span> item.name == <span class="st">"caerphilly"</span>: <span class="kw">return</span> <span class="ot">True</span><br>form.find_control(kind=<span class="st">"list"</span>, predicate=control_has_caerphilly)<br><br><span class="co"># HTMLForm.controls is a list of all controls in the form</span><br><span class="kw">for</span> control in form.controls:<br><span class="kw">if</span> control.value == <span class="st">"inquisition"</span>: sys.exit()<br><br><span class="co"># Control.items is a list of all Item instances in the control</span><br><span class="kw">for</span> item in form.find_control(<span class="st">"cheeses"</span>).items:<br><span class="kw">print</span> item.name<br><br><span class="co"># To remove items from a list control, remove it from .items:</span><br>cheeses = form.find_control(<span class="st">"cheeses"</span>)<br>curd = cheeses.get(<span class="st">"curd"</span>)<br><span class="kw">del</span> cheeses.items[cheeses.items.index(curd)]<br><span class="co"># To add items to a list container, instantiate an Item with its control</span><br><span class="co"># and attributes:</span><br><span class="co"># Note that you are responsible for getting the attributes correct here,</span><br><span class="co"># and these are not quite identical to the original HTML, due to</span><br><span class="co"># defaulting rules and a few special attributes (e.g. Items that represent</span><br><span class="co"># OPTIONs have a special "contents" key in their .attrs dict).  In future</span><br><span class="co"># there will be an explicitly supported way of using the parsing logic to</span><br><span class="co"># add items and controls from HTML strings without knowing these details.</span><br>mechanize.Item(cheeses, {<span class="st">"contents"</span>: <span class="st">"mascarpone"</span>,<br><span class="st">"value"</span>: <span class="st">"mascarpone"</span>})<br><br><span class="co"># You can specify list items by label using set/get_value_by_label() and</span><br><span class="co"># the label argument of the .get() method.  Sometimes labels are easier to</span><br><span class="co"># maintain than names, sometimes the other way around.</span><br>form.set_value_by_label([<span class="st">"Mozzarella"</span>, <span class="st">"Caerphilly"</span>], <span class="st">"cheeses"</span>)<br><br><span class="co"># Which items are present, selected, and successful?</span><br><span class="co">#  is the "parmesan" item of the "cheeses" control successful (selected</span><br><span class="co">#   and not disabled)?</span><br><span class="kw">print</span> <span class="st">"parmesan"</span> in form[<span class="st">"cheeses"</span>]<br><span class="co">#  is the "parmesan" item of the "cheeses" control selected?</span><br><span class="kw">print</span> <span class="st">"parmesan"</span> in [<br>    item.name <span class="kw">for</span> item in form.find_control(<span class="st">"cheeses"</span>).items <span class="kw">if</span> item.selected]<br><span class="co">#  does cheeses control have a "caerphilly" item?</span><br><span class="kw">print</span> <span class="st">"caerphilly"</span> in [item.name <span class="kw">for</span> item in form.find_control(<span class="st">"cheeses"</span>).items]<br><br><span class="co"># Sometimes one wants to set or clear individual items in a list, rather</span><br><span class="co"># than setting the whole .value:</span><br><span class="co">#  select the item named "gorgonzola" in the first control named "cheeses"</span><br>form.find_control(<span class="st">"cheeses"</span>).get(<span class="st">"gorgonzola"</span>).selected = <span class="ot">True</span><br><span class="co"># You can be more specific:</span><br><span class="co">#  deselect "edam" in third CHECKBOX control</span><br>form.find_control(<span class="dt">type</span>=<span class="st">"checkbox"</span>, nr=<span class="dv">2</span>).get(<span class="st">"edam"</span>).selected = <span class="ot">False</span><br><span class="co">#  deselect item labelled "Mozzarella" in control with id "chz"</span><br>form.find_control(<span class="dt">id</span>=<span class="st">"chz"</span>).get(label=<span class="st">"Mozzarella"</span>).selected = <span class="ot">False</span><br><br><span class="co"># Often, a single checkbox (a CHECKBOX control with a single item) is</span><br><span class="co"># present.  In that case, the name of the single item isn't of much</span><br><span class="co"># interest, so it's a good idea to check and uncheck the box without</span><br><span class="co"># using the item name:</span><br>form.find_control(<span class="st">"smelly"</span>).items[<span class="dv">0</span>].selected = <span class="ot">True</span>  <span class="co"># check</span><br>form.find_control(<span class="st">"smelly"</span>).items[<span class="dv">0</span>].selected = <span class="ot">False</span>  <span class="co"># uncheck</span><br><br><span class="co"># Items may be disabled (selecting or de-selecting a disabled item is</span><br><span class="co"># not allowed):</span><br>control = form.find_control(<span class="st">"cheeses"</span>)<br><span class="kw">print</span> control.get(<span class="st">"emmenthal"</span>).disabled<br>control.get(<span class="st">"emmenthal"</span>).disabled = <span class="ot">True</span><br><span class="co">#  enable all items in control</span><br>control.set_all_items_disabled(<span class="ot">False</span>)<br><br>request2 = form.click()  <span class="co"># mechanize.Request object</span><br><span class="kw">try</span>:<br>    response2 = mechanize.urlopen(request2)<br><span class="kw">except</span> mechanize.HTTPError, response2:<br><span class="kw">pass</span><br><br><span class="kw">print</span> response2.geturl()<br><span class="co"># headers</span><br><span class="kw">for</span> name, value in response2.info().items():<br><span class="kw">if</span> name != <span class="st">"date"</span>:<br><span class="kw">print</span> <span class="st">"</span>%s<span class="st">: </span>%s<span class="st">"</span> % (name.title(), value)<br><span class="kw">print</span> response2.read()  <span class="co"># body</span><br>response2.close()<br></pre>
<p>All of the standard control types are supported: <code>TEXT</code>, <code>PASSWORD</code>, <code>HIDDEN</code>, <code>TEXTAREA</code>, <code>ISINDEX</code>, <code>RESET</code>, <code>BUTTON</code> (<code>INPUT TYPE=BUTTON</code> and the various <code>BUTTON</code> types), <code>SUBMIT</code>, <code>IMAGE</code>, <code>RADIO</code>, <code>CHECKBOX</code>, <code>SELECT</code>/<code>OPTION</code> and <code>FILE</code> (for file upload). Both standard form encodings (<code>application/x-www-form-urlencoded</code> and <code>multipart/form-data</code>) are supported.</p>
<p>The module is designed for testing and automation of web interfaces, not for implementing interactive user agents.</p>
<p><strong><em>Security note</em>: Remember that any passwords you store in <code>HTMLForm</code> instances will be saved to disk in the clear if, for example, you <a href="http://docs.python.org/library/pickle.html">pickle</a> them.</strong></p>
<div id="parsers">
<h2>Parsers</h2>
<p>There are two parsers.</p>
<p>TODO: more!</p>
<p>See also the FAQ entries on <a href="faq.html#xhtml">XHTML</a> and <a href="./faq.html#parsing">parsing bad HTML</a>.</p>
</div>
<div id="backwards-compatibility-mode">
<h2>Backwards-compatibility mode</h2>
<p>mechanize (and ClientForm 0.2) includes three minor backwards-incompatible interface changes from ClientForm version 0.1.</p>
<p>To make upgrading from ClientForm 0.1 easier, and to allow me to stop supporting version ClientForm 0.1 sooner, there is support for operating in a backwards-compatible mode, under which code written for ClientForm 0.1 should work without modification. This is done on a per-<code>HTMLForm</code> basis via the <code>.backwards_compat</code> attribute, but for convenience the <code>ParseResponse()</code> and <code>ParseFile()</code> factory functions accept <code>backwards_compat</code> arguments. These backwards-compatibility features will be removed soon. The default is to operate in backwards-compatible mode. To run with backwards compatible mode turned <em><strong>OFF</strong></em> (<strong>strongly recommended</strong>):</p>
<pre class="sourceCode python"><span class="ch">from</span> mechanize <span class="ch">import</span> ParseResponse, urlopen<br>forms = ParseResponse(urlopen(<span class="st">"http://example.com/"</span>), backwards_compat=<span class="ot">False</span>)<br><span class="co"># ...</span><br></pre>
<p>The backwards-incompatible changes are:</p>
<ul>
<li><p>Ambiguous specification of controls or items now results in AmbiguityError. If you want the old behaviour, explicitly pass <code>nr=0</code> to indicate you want the first matching control or item.</p></li>
<li><p>Item label matching is now done by substring, not by strict string-equality (but note leading and trailing space is always stripped). (Control label matching is always done by substring.)</p></li>
<li><p>Handling of disabled list items has changed. First, note that handling of disabled list items in ClientForm 0.1 (and in ClientForm 0.2&#8217;s backwards-compatibility mode!) is buggy: disabled items are successful (ie. disabled item names are sent back to the server). As a result, there was no distinction to be made between successful items and selected items. In ClientForm 0.2, the bug is fixed, so this is no longer the case, and it is important to note that list controls&#8217; <code>.value</code> attribute contains only the <em>successful</em> item names; items that are <em>selected</em> but not successful (because disabled) are not included in <code>.value</code>. Second, disabled list items may no longer be deselected: AttributeError is raised in ClientForm 0.2, whereas deselection was allowed in ClientForm 0.1. The bug in ClientForm 0.1 and in ClientForm 0.2&#8217;s backwards-compatibility mode will not be fixed, to preserve compatibility and to encourage people to upgrade to the new ClientForm 0.2 <code>backwards_compat=False</code> behaviour.</p></li>
</ul>
</div>

<p>I prefer questions and comments to be sent to
the <a href="http://lists.sourceforge.net/lists/listinfo/wwwsearch-general">mailing
list</a> rather than direct to me.</p>

<p><a href="mailto:jjl@pobox.com">John J. Lee</a>, April 2010.

</p>
<hr>
</div>
</div>
</body>
</html>

